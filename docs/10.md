# Nest의 Guards

```
[ 클라이언트 ] --- (HTTP 요청) --> [ 가드 ] --- --> [   라우트 핸들러
                                                      (@RequestMapping)  ]
```

인증은 "당신이 누구인가?" 를 판단하는 것이다. 미들웨어로 구현하며, 적절한 JWT 토큰을 보유중인지 확인하는 방향으로 구현한다.

인가는 "당신이 무엇을 할 수 있나?"를 판단하는 것이다. 토큰이 가진 내용을 토대로 permission, role, ACL(Access control list) 같은 개념을 사용하여 리소스의 처리 여부를 판단한다. Nest의 Guards로 구현한다.

> 🍅 notes!
>
> 실패 시 전달하는 HTTP status code는 아래와 같다:
>
> 인증 실패 시 401 Unauthorized를,
>
> 인가 실패 시 403 Forbidden을 사용한다.
>
> [참고 링크](https://auth0.com/blog/forbidden-unauthorized-http-status-codes/)를 읽어보자.

인가는 인증처럼 미들웨어로 구현할 수 없다. 미들웨어는 실행 컨텍스트(`ExecutionContext`)에 접근할 수 없기 때문이다. 자신의 일만 수행하고 `next()` 를 호출하기 때문에 다음에 어떤 핸들러가 실행될 지 알 수 없다. Guards는 실행 컨텍스트 인스턴스에 접근할 수 있고, 다음 실행될 작업을 알 수 있다.

## 10.2 Guards를 이용한 인가

간단한 인가 기능을 구현해보자.

> 🍅 tips
> 
> 실제 인가는, 비즈니스 규칙에 의거하여 세밀하게 작성한다.
>
> E.g., 사용자의 가입 요금제에 따라 서비스에서 제공하는 기능이 다른 경우,
>
> 요청 객체에 포함된 정보(토큰)를 분석 후 사용자가 해당 기능을 이용할 수 있는지 판단

Guards는 `CanActivate` 인터페이스를 구현해야 한다. 구현할 클래스 명을 `AuthGuard` 로 두자.

```ts
import { CanActivate, ExecutionContext, Injectable } from '@nestjs/common';
import { Observable } from 'rxjs';

@Injectable()
export class AuthGuard implements CanActivate {
  canActivate(
    context: ExecutionContext,
  ): boolean | Promise<boolean> | Observable<boolean> {
    const request = context.switchToHttp().getRequest();
    return this.validateRequest(request);
  }

  private validateRequest(request: any) {
    // fixme
    //  request를 써서 로직 구현필요!
    return true;
  }
}
```

### 10.2.1 실행 컨텍스트

`canActivate()` 함수 분석

1. 아규먼트: `ExecutionContext` 컨텍스트
    - 이는 `ArgumentsHost`를 상속받음. 여기 요청/응답에 대한 정보가 있음
    - 해당 컨텍스트를 `switchToHttp()` 로 필요 정보를 가져올 수 있음 (rpc, ws도 가능!)
2. 이 후 내부적으로 정의한 `validateRequest` 메소드로 세부 처리를 할 수 있음

### 10.2.2 가드 적용

예외 필터 적용과 유사하다. 컨트롤러 범위, 메소드 범위로 적용하고자 한다면 `@UseGuards(AuthGuard)` 형태로 사용하면 된다(인스턴스 생성은 Nest가 관리). 여러 가드를 적용하려면 `,`로 이어서 적용한다.

컨트롤러에 가드를 추가하는 예시를 살펴보자:

```ts
@UseGuards(AuthGuard)
@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @UseGuards(AuthGuard)
  @Get()
  getHello(): string {
    return this.appService.getHello();
  }
}
```

전역으로 가드를 추가하려면 부트스트랩 과정을 수정한다:

```ts
...
async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  app.useGlobalGuards(new AuthGuard());
  await app.listen(3000);
}
bootstrap();
```

가드에 종속성 주입을 사용하여 다른 프로바이더를 주입 후 사용하고싶다면, 커스텀 프로바이더로 선언해야함.

> `src/app.module.ts` 에 추가하는 예시

```ts
import { Module } from '@nestjs/common';
import { APP_GUARD } from '@nestjs/core';

@Module({
  providers: [
    {
      provide: APP_GUARD,
      useClass: AuthGuard,
    },
  ],
})
export class AppModule {}
```

## 10.3 인증

인가를 테스트해봤으니, 인증을 테스트해보자.

ID, 비밀번호를 한 번 입력하면 그 후에는 일정 기간동안은 로그인 된 상황이어야 하는 것이 보통의 UX이다. 이를 하기 위해서는 여러 인증방식이 있다. 이 책에서는 JWT를 이용한 인증 구현방안을 소개한다.

## 10.4 JWT (JSON Web Token)

`헤더.페이로드.시그니처` 로 구성된 토큰.

### 10.4.1 헤더

JWT의 유형과 인코딩된 알고리즘을 표현

- `typ`
- `alg`

### 10.4.2 페이로드

aka. 클레임

#### registered claim

JWT 상호호환성을 위해 필요한 값

- `sub`(subject)
- `aud`(audience)
- `exp`(expiration)
- `nbf`(not before): 이 시간 이후 활성화, UNIX Epoch time
- `iat`(issued at): 발급시간, UNIX Epoch time
- `jti`(JWT id): 토큰 고유식별자

#### public claim

표준 클레임에 덧붙여도 무방한 값. 보통 URI 형식으로 정의함

#### private claim

JWT 발급자와 사용자 간 약속한 클레임. 도메인에 필요한 이름/값이다.

> 🍅🍅 WARNING 🍅🍅
>
> 페이로드에 들어간 비공개 클레임은 비밀번호 같은 주요정보를 넣으면 안 된다.
>
> 시그니처는 토근이 유효한지만 검사할 뿐, **페이로드를 암호화는 것이 아니다.**

### 10.4.3 시그니처

헤더, 페이로드는 `base64`로만 인코딩한다. 토큰을 유효한지 검증하는 값이 시그니처다.

E.g., 헤더의 `alg` 값이 `HS256` 이면, 이 토큰은 `HMAC-SHA256` 알고리즘으로 암호화 해야한다. 암호화 시 사용하는 `SECRET` 값은 서버에서만 안전한 방법으로 저장해야한다.

HS256의 암호화 방식은 아래와 같다:

```
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  'secret'
)
```

## 10.5 유저 서비스의 이메일 인증 처리와 JWT 발급

### 10.5.1 회원 가입 이메일 인증

이메일 인증을 통한 회원가입 완료 후, 응답으로 토큰발급 후 로그인 상태로 변경하는 로직을 작성해보자.